---
description: Workflow for generating a PowerPoint presentation from an input document. Use when the user asks to generate, create, build, or make a presentation or slide deck.
globs:
alwaysApply: false
---

# Generate Presentation Workflow

Follow these 8 steps to generate a PowerPoint presentation from an input document. Steps 1-5 are purely content work. Step 6 is where all design decisions happen. Steps 7-8 build and deliver.

## Prerequisites

- Input document exists (PDF, DOCX, PPTX, TXT, or MD)
- Design system YAML exists in `design_systems/` (use the appropriate brand YAML)
- Python environment is set up with dependencies from `pyproject.toml`
- Template registry exists at `template_registry.json` (run the analyze-templates workflow first if missing)

---

## Step 1: Parse the Input Document

Run the parser script to extract text content:

```
python scripts/parse_input.py <input_file> -o workspace/parsed_content.txt
```

Verify the output file was created and has content.

## Step 2: Assess Content Maturity

Read `workspace/parsed_content.txt` and assess how ready the content is for a presentation.

Follow the guidance in the **content-maturity** rule. Write the result to `workspace/content_maturity.json`.

```
python scripts/validate_schema.py workspace/content_maturity.json ContentMaturity
```

**Report the assessment to the user** — tell them the maturity level (1-4), what stages will run, and key gaps/strengths. Ask if they agree or want to override.

The maturity level determines which sub-steps run in Steps 3.5 and 4:

| Level | Label | Steps include |
|---|---|---|
| 1 | Raw ideas | Content Planning → Research → Content Development → Editor |
| 2 | Outline | Content Planning → Content Development → Editor |
| 3 | Draft | Content Planning → Editor |
| 4 | Ready | Narrative Architecture only |

## Step 3: Extract Content Inventory

Read `workspace/parsed_content.txt` and produce a structured content inventory.

Follow the guidance in the **content-extraction** rule. Write the result to `workspace/content_inventory.json`.

```
python scripts/validate_schema.py workspace/content_inventory.json ContentInventory
```

## Step 3.5: Plan Deck Structure (Content Planner)

For maturity Levels 1-3, run the Content Planner to produce a structural blueprint before content development begins.

Follow the **content-planner** rule. Read `workspace/content_inventory.json` (and `workspace/researched_outline.json` if it exists from a Level 1 Research Agent pre-pass) and produce `workspace/deck_plan.json`.

```
python scripts/validate_schema.py workspace/deck_plan.json DeckPlan
```

The deck plan decides:
- How many slides each section gets (deep / standard / light / skip)
- What content needs to be expanded or created from scratch
- What new sections the presentation needs that aren't in the input
- The narrative sequence and overall visual strategy

**Report the deck plan to the user** — total planned slides, depth breakdown, new sections being created, and key expansion needs. Ask if they want to adjust before proceeding.

For **Level 4**, skip this step — go directly to Narrative Architecture in Step 4.

## Step 4: Research, Write, and Edit Content

This step adapts based on content maturity. All sub-steps below are about **content only** — no design decisions yet.

### Level 1: Research Agent

Follow the **research-agent** rule. Read `workspace/content_inventory.json` and `workspace/deck_plan.json` and produce `workspace/researched_outline.json`.

### Levels 1-2: Content Development Agent

Follow the **content-development** rule. Read `workspace/deck_plan.json` as the primary structural input (it dictates how many slides per section, what to expand, and what to create). Produce `workspace/developed_content.json`.

### Levels 1-3: Editor Agent

Follow the **editor-agent** rule. This polishes titles, tightens bullets, refines speaker notes, and ensures narrative flow.

### Level 4: Narrative Architecture

Follow the **narrative-architecture** rule. Read `workspace/content_inventory.json` and produce the deck plan directly.

## Step 5: Organize Content into Slides

The output of Step 4 is `workspace/deck_schema.json` — a complete slide-by-slide specification with titles, content blocks, speaker notes, slide types, and layout hints.

Validate it:

```
python scripts/validate_schema.py workspace/deck_schema.json DeckSchema
```

If validation fails, fix and re-validate. The deck schema must be complete and correct before proceeding to design.

**At this point, all content work is done.** Every slide has its final text, bullets, speaker notes, and narrative intent. Steps 6+ are purely about visual design and building.

## Step 6: Build Branded HTML Deck

This is the core creative step — where content meets design. The output is a fully branded HTML file that is both a browser-viewable presentation and the precise specification for the PPTX builder.

Follow the guidance in the **html-composition** rule.

### 6a. Run template matching

If `template_registry.json` exists:

```
python scripts/match_templates.py workspace/deck_schema.json template_registry.json -o workspace/template_matches.json
```

### 6a.1. Assess template fit (clone vs compose)

Run the content-zone fit assessment to verify that template-matched slides genuinely fit their content. Slides that fail are demoted from clone mode to compose mode:

```
python scripts/assess_template_fit.py workspace/deck_schema.json workspace/template_matches.json template_registry.json -o workspace/template_matches.json --fit-report workspace/fit_report.json
```

Review the fit report. Clone-mode slides must have content zones that map to the deck schema content blocks. Slides without good zone coverage are demoted to compose mode (built from scratch using the design system).

**Two build modes result from this step:**
- **Clone** (`data-build-mode="clone"`): Template slide is pasted as-is, text replaced in named shapes only, unmapped shapes cleared. Zero new textboxes.
- **Compose** (`data-build-mode="compose"`): Slide built from branded layout (master background preserved), all content as new textboxes from the design system.

### 6b. Generate scaffold HTML

Run the renderer to auto-generate an initial branded HTML from the deck schema:

```
python scripts/render_html.py workspace/deck_schema.json \
    -o workspace/deck_preview.html \
    --design-system <design_system_yaml> \
    --matches workspace/template_matches.json \
    --template-registry template_registry.json
```

The scaffold includes:
- CSS custom properties from the design system (all brand colors, fonts, sizes as `var(--token)`)
- Auto-styling rules per slide type and visual profile
- Template background colors for accurate branded preview
- Content mapped to template zones

### 6c. Compose the final HTML

Read `workspace/deck_preview.html` and compose the branded presentation. This is where you make every design decision:

- Edit text to fit template zones (move overflow to speaker notes)
- Set element positions, sizes, fonts, and colors using the design system tokens
- Choose backgrounds per slide (template clone or solid brand color)
- Ensure visual consistency (section headers match, bookend slides match)
- Manage content density (trim rather than overflow)

Write the final HTML back to `workspace/deck_preview.html`.

The HTML file should look like a polished presentation when opened in a browser.

## Step 7: Build PPTX from HTML

Run the HTML-to-PPTX builder:

```
python scripts/build_from_html.py workspace/deck_preview.html \
    -o output/presentation.pptx \
    --base-template "templates/base/Shopify - Example Technical Workshop Slide Bank.pptx"
```

The builder reads `data-build-mode` on each slide and follows two clean paths:

- **Clone mode** (`data-build-mode="clone"`): Clones the referenced template slide from the PPTX (all backgrounds, images, decorations preserved). Replaces text ONLY in named shapes (`data-shape-name`). Clears stale text from unmapped shapes. Creates zero new textboxes.
- **Compose mode** (`data-build-mode="compose"`): Creates a slide from the base template layout (branded master backgrounds inherited). Builds all text elements as new textboxes at exact CSS positions with specified fonts, sizes, colors.
- Speaker notes: transferred from hidden divs in both modes.

Also copy the final HTML alongside the PPTX:

```
cp workspace/deck_preview.html output/presentation.html
```

## Step 8: Quality Check and Deliver

Run programmatic quality checks:

```
python scripts/quality_check.py output/presentation.pptx --design-system <design_system_yaml> --describe
```

Follow the **quality-review** rule to provide a narrative assessment.

Report to the user:
- Slide count and quality summary
- Output files: `output/presentation.pptx` and `output/presentation.html`
- Any issues that need attention

---

## Pipeline Summary

```
Input Document
    │
    ▼
1. [Parse] ──► parsed_content.txt
    │
    ▼
2. [Assess Maturity] ──► content_maturity.json
    │
    ▼
3. [Extract Content] ──► content_inventory.json
    │
    ▼
3.5 [Plan Deck Structure] ──► deck_plan.json
    │   (depth decisions, expansion briefs, new sections, narrative sequence)
    │
    ▼
4. [Research / Write / Edit] ──► deck_schema.json
    │   (guided by deck_plan.json, adapts per maturity level)
    │
    ▼
5. [Validate Deck Schema] ──► content complete, ready for design
    │
    ▼
6. [Build Branded HTML] ──► deck_preview.html
    │   ├── template matching (algorithmic)
    │   ├── template fit assessment (clone vs compose)
    │   ├── scaffold generation (render_html.py)
    │   └── agent composes final branded HTML
    │
    │   Clone slides: data-build-mode="clone" + data-shape-name on elements
    │   Compose slides: data-build-mode="compose" + all new textboxes
    │
    ▼
7. [Build PPTX from HTML] ──► output.pptx
    │   Clone: paste template slide, replace named shapes, clear rest
    │   Compose: branded layout + new textboxes from scratch
    ▼
8. [Quality Check] ──► quality_report.json
```

## Error Handling

- If any script fails, read the error output and fix the issue
- If JSON validation fails, review the schema definition in `src/schemas/` and correct the JSON
- If the build step fails, check that the HTML is well-formed
- If quality issues are severe, edit `workspace/deck_preview.html` and re-run Step 7
- If the user disagrees with the maturity assessment, let them override and adjust the pipeline
